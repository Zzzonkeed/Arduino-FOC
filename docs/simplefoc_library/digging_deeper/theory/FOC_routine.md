---
layout: default
title: Field Oriented Control 
parent: Theory corner
grand_parent: Digging deeper
grand_grand_parent: Arduino <span class="simple">Simple<span class="foc">FOC</span>library</span>
description: "Arduino Simple Field Oriented Control (FOC) library ."
nav_order: 1
permalink: /foc_theory
---

# Field Oriented Control algorithm briefly

Field oriented control algorithm's main task is to take user defined voltage <i>u<sub>q</sub></i> and, by continuously reading the position of the motor rotor <i>a</i>, calculate the appropriate phase voltages <i>u<sub>a</sub></i>,<i>u<sub>b</sub></i> and <i>u<sub>c</sub></i>. 

<img src="../extras/Images/voltage_loop.png">

FOC algorithm calculates the phase voltages which create the magnetic field in the motor's rotor which are exactly 90 degrees "behind" the magnetic field of the permanent magnets of the rotor, creating a pushing effect. Here is a very nice animation of what happens inside of the motor when running simplified version of the the FOC called six-step modulation. 

<iframe src='https://gfycat.com/ifr/MealyDeafeningHarpyeagle' frameborder='0' scrolling='no' allowfullscreen width='640' height='404'></iframe><p> <a href="https://gfycat.com/mealydeafeningharpyeagle">via Gfycat</a></p>

Another way to look at why we need 90 degree angle in between rotor and stator fields if by remembering the equation of the electric force generated by the wire passing through the magnetic field:

```cpp
F = B*I*L*sin(alpha)
```

Where `B` is the strength of the magnetic field, `L` is the length of the wire,  `I` is the electric current magnitude and the `alpha` is the angle in between magnetic field `B` and current `I`. From this equation we can see that in order to have the maximum force `F = B*I*L` we need to maintain `alpha` angle equal to 90 degrees or `PI/2` radians.

## How to calculate the appropriate voltages <i>u<sub>a</sub></i>,<i>u<sub>b</sub></i> and <i>u<sub>c</sub></i> 

Since the <span class="simple">Simple<span class="foc">FOC</span>library</span> is intended for education about the FOC algorithm as well for enabling various applications, there are two versions of the FOC modulation implemented in this library. 

- Sinusoidal PWM: `SinePWM`
- Space Vector PWM: `SpaceVectorPWM`

You can configure them by setting the value of `motor.foc_modulation` variable:
```cpp
motor.foc_modulation = FOCModulationType::SinePWM; // default
// or
motor.foc_modulation = FOCModulationType::SpaceVectorPWM;
```

These are the two most standard approaches to calculating appropriate phase voltages from desired voltage <i>U<sub>q</sub></i>.

Sinusoidal | Space Vector
--- | ---
<img src="../extras/Images/0.5.jpg" class="img400"> | <img src="../extras/Images/svm0.5.jpg"  class="img400">


### Sinusoidal commutation `SinePWM`

The default  `voltage_power_supply`  value is set to `12V`. If you set your power supply to some other value, change it here for the control loops to adapt.
```cpp
// power supply voltage
motor.voltage_power_supply = 12;
```
The `voltage_power_supply` value tells the FOC algorithm what is the maximum voltage it can output. Additionally since the FOC algorithm implemented in the Simple FOC library uses sinusoidal voltages the magnitudes of the sine waves exiting the Driver circuit is going to be  `[-voltage_power_supply/2, voltage_power_supply/2]`.

<img src="../extras/Images/sine_foc.png" >


### Space vector commutation `SpaceVectorPWM`

> Full documentation will be available shortly